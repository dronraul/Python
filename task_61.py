# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах
# возьмем уже анализированный код из 4 домашнего задания
# Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…
# # Количество элементов (n) вводится с клавиатуры
import sys
n = 100


def show_size(x, level=0):
    if hasattr(x, '__iter__'):
        if hasattr(x, 'items'):
            for key, value in x.items():
                show_size(key, level + 1)
                show_size(value, level + 1)
        elif not isinstance(x, str):
            for item in x:
                show_size(item, level + 1)
    return sys.getsizeof(x)

# первый способ - через сумму ряда циклом


a = 1
s = 0
for i in range(0, n):
    s += a
    a *= (-0.5)
size1 = show_size(a) + show_size(s) + show_size(i) + show_size(n)

# второй способ - через сумму прогрессии

f = (1-(-0.5)**n)/1.5

size2 = show_size(f) + show_size(n)

# третий способ - заполняем массив и находим его сумму

m = [1]
b = 1
for j in range(1, n):
    b *= (-0.5)
    m += [b]
    su = sum(m)
size3 = show_size(n) + show_size(m) + show_size(b) + show_size(su) + show_size(j)


print(size1, size2, size3)

# значение переменной n влияет на количество используемой памяти в некоторых вариантах, поэтому
# было произведено три замера - для n равного 5, 10, 100
# результаты замеров для size1, size2, size3 соответственно:
# n = 5:   104 52 208
# n = 10:  104 52 304
# n = 100: 104 52 1032

# Выводы: Как и в задании с подсчетом скорости выполнения, мы видим явное преимущество второго варианта,
# более того, если на первый и второй вариант никак не влияет количество элементов ряда, то
# в третьем варианте, напротив,с ростом n наблюдается увеличесние используемой памяти в связи с использовнием
# массива с хранием всей промежуточной информации.
# PS лишние выводы из программы убрал, но перед жтимправильность работы проверил
# PS1 Python 3.7, Win7*64
